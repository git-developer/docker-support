variables:
  BUILD_CONTEXT: "."
  IMAGE_NAME: "${CI_PROJECT_PATH}"
  IMAGE_VERSION: "latest"
  IMAGE_PLATFORMS: "linux/amd64"
  DOCKER_VERSION: "19.03.8"
  DOCKER_BUILDX_VERSION: "v0.3.1"
  DOCKER_CREDENTIAL_PASS_VERSION: "v0.6.3"
  DOCKER_CLI_EXPERIMENTAL: "enabled"
  BUILD_CACHE: "build-cache"

  PIPELINE_MODE: "build"
  DOWNSTREAM_PROJECT: "${CI_PROJECT_PATH}"
  DOWNSTREAM_REF:     "${CI_COMMIT_REF_NAME}"
  IMAGE_REPOSITORY:   "${CI_PROJECT_PATH}"
  APPLICATION_URLS:   "${CI_REPOSITORY_URL}"

default:
  artifacts:
    expire_in: 1 hour

##
# Download and configure buildx for multiarch builds.
##
.docker_support:.build_image:.configure_multiarch_builder: &configure_multiarch_builder |
  docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
  mkdir -p ~/.docker/cli-plugins
  wget -q -O ~/.docker/cli-plugins/docker-buildx "https://github.com/docker/buildx/releases/download/${DOCKER_BUILDX_VERSION}/buildx-${DOCKER_BUILDX_VERSION}.linux-amd64"
  chmod +x ~/.docker/cli-plugins/docker-buildx
  docker buildx create --use --name builder

##
# Download and configure the docker credential helper for 'pass'.
#
# This job initializes a password store with the passphrase $GPG_PASSPHRASE
# or a random password as fallback. The password store will be used to store
# the credentials to the image registry.
# Without a credential helper, the credentials to the docker registry are
# stored in a plain text file.
##
.docker_support:.build_image:.configure_docker_auth_pass: &configure_docker_auth_pass |
  wget -q -O - "https://github.com/docker/docker-credential-helpers/releases/download/${DOCKER_CREDENTIAL_PASS_VERSION}/docker-credential-pass-${DOCKER_CREDENTIAL_PASS_VERSION}-amd64.tar.gz" | tar -C /usr/bin -xz
  chmod +x /usr/bin/docker-credential-pass
  apk add gnupg
  apk add --no-cache -X https://alpine.global.ssl.fastly.net/alpine/edge/community pass
  export gpg_passphrase="${GPG_PASSPHRASE:-$(cat /dev/urandom | tr -dc 'a-zA-Z0-9!#%&*+,-./:;<=>?@^_~;' | fold -w 64 | head -n 1)}"
  cat <<EOF | gpg --batch --gen-key
  Key-Type: 1
  Name-Real: docker-credential-pass
  Passphrase: ${gpg_passphrase}
  EOF
  gpg --list-keys docker-credential-pass | grep -o '^\s\(.*\)' | tr -d ' ' | xargs pass init
  echo 'pass is initialized' | pass insert -e docker-credential-helpers/docker-pass-initialized-check
  <<EOF gpg --passphrase-fd 0 --pinentry-mode loopback -d ~/.password-store/docker-credential-helpers/docker-pass-initialized-check.gpg
  ${gpg_passphrase}
  EOF
  unset gpg_passphrase
  mkdir -p ~/.docker
  echo "{\"credsStore\":\"pass\"}" >~/.docker/config.json

##
# Base job for build jobs (in contrast to the update-check job
# '.docker_support:.trigger_on_update:').
##
.docker_support:.build_job:
  rules:
  - if: '$PIPELINE_MODE == "build"'

##
# Write default tags to the tags directory.
##
.docker_support:.collect_tags:
  extends: .docker_support:.build_job
  image: "alpine"
  before_script:
  - set -euo pipefail
  script:
  - mkdir -p tags
  - echo >"tags/${IMAGE_VERSION}" "${IMAGE_NAME}:${IMAGE_VERSION}"
  artifacts:
    paths:
    - tags

##
# Write default labels to the labels directory.
#
# Default labels are created for the OCI defined annotations.
# Metadata is taken from pre-defined project variables and the GitLab API.
##
.docker_support:.collect_labels:
  extends: .docker_support:.build_job
  image: "alpine"
  before_script:
  - set -euo pipefail
  script:
  - apk add wget jq coreutils
  - gitlab_project_metadata="$(wget -q -O - "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}?license=yes")"
  - gitlab_users_metadata="$(  wget -q -O - "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/users")"
  - value_of() { printf "%s" "${gitlab_project_metadata}" | jq -r "${1} // empty"; }
  - authors="$(printf "%s" "${gitlab_users_metadata}" | jq -r '. | map((.name // empty) + if .web_url != null then " ("+.web_url+")" else "" end) | join(", ")')"
  - oci='org.opencontainers.image'
  - mkdir -p labels
  - echo >"labels/${oci}.vendor"   "${oci}.vendor=${IMAGE_VENDOR:-${CI_PROJECT_NAMESPACE}}"
  - echo >"labels/${oci}.title"    "${oci}.title=${IMAGE_TITLE:-${IMAGE_NAME##*/}}"
  - echo >"labels/${oci}.version"  "${oci}.version=${IMAGE_VERSION}"
  - echo >"labels/${oci}.created"  "${oci}.created=${IMAGE_CREATED:-$(date -u --rfc-3339 seconds)}"
  - echo >"labels/${oci}.authors"  "${oci}.authors=${IMAGE_AUTHORS:-${authors}}"
  - echo >"labels/${oci}.url"      "${oci}.url=${IMAGE_URL:-${CI_PROJECT_URL}}"
  - echo >"labels/${oci}.revision" "${oci}.revision=${IMAGE_REVISION:-${CI_COMMIT_SHA}}"
  - echo >"labels/${oci}.ref.name" "${oci}.ref.name=${IMAGE_REF_NAME:-${CI_COMMIT_REF_NAME}}"
  - IMAGE_DOCUMENTATION="${IMAGE_DOCUMENTATION:-$(value_of .readme_url)}"
  - if [ -n "${IMAGE_DOCUMENTATION}" ]; then echo >"labels/${oci}.documentation" "${oci}.documentation=${IMAGE_DOCUMENTATION}"; fi
  - IMAGE_LICENSES="${IMAGE_LICENSES:-$(value_of .license.key)}"
  - if [ -n "${IMAGE_LICENSES}" ]; then echo >"labels/${oci}.licenses" "${oci}.licenses=${IMAGE_LICENSES}"; fi
  - IMAGE_DESCRIPTION="${IMAGE_DESCRIPTION:-$(value_of .description)}"
  - if [ -n "${IMAGE_DESCRIPTION}" ]; then echo >"labels/${oci}.description" "${oci}.description=${IMAGE_DESCRIPTION}"; fi
  artifacts:
    paths:
    - labels

##
# Write buid arguments to the build-args directory.
##
.docker_support:.collect_build_args:
  extends: .docker_support:.build_job
  image: "alpine"
  rules:
  - if: '$PIPELINE_MODE == "build" && $BUILD_ARGS'
  before_script:
  - set -euo pipefail
  script:
  - mkdir -p build-args
  - echo "${BUILD_ARGS-}" | tr ' ' '\n' | while read build_arg; do [ -z "${build_arg}" ] || echo >"build-args/${build_arg%%=*}" "${build_arg}"; done
  artifacts:
    paths:
    - build-args

##
# Base job for build jobs using Docker-in-Docker
##
.docker_support:.base:
  image: "docker:${DOCKER_VERSION}"
  extends: .docker_support:.build_job
  services:
  - name: "docker:${DOCKER_VERSION}-dind"

##
# Build the bare docker image without tags and labels
# and store it in the build cache.
##
.docker_support:.build_bare_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
  script:
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS}"
        printf "%s\0" "--cache-to" "type=local,dest=${BUILD_CACHE},mode=max"
        printf "%s\0" "--tag" "${IMAGE_NAME}:${BUILD_CACHE}"
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build
  artifacts:
    paths:
    - "${BUILD_CACHE}"

##
# Base job for jobs that use the bare image,
# e.g. to analyze it and create additional tags from
# the application version.
##
.docker_support:.with_bare_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS%%,*}"
        printf "%s\0" "--load"
        [ ! -d "${BUILD_CACHE}" ] || printf "%s\0" "--cache-from" "type=local,src=${BUILD_CACHE}"
        printf "%s\0" "--tag" "${IMAGE_NAME}:${BUILD_CACHE}"
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build

##
# Read the bare image, add alls tags and labels and push it to the registry.
# The default registry may be overriden by GitLab variables
# CI_REGISTRY, CI_REGISTRY_USER and CI_REGISTRY_PASSWORD.
##
.docker_support:.publish_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
    - *configure_docker_auth_pass
    - |
      <<EOF docker login -u "${CI_REGISTRY_USER}" --password-stdin ${CI_REGISTRY:+"${CI_REGISTRY}"}
      ${CI_REGISTRY_PASSWORD}
      EOF
  script:
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS}"
        printf "%s\0" "--push"
        [ ! -d "${BUILD_CACHE}" ] || printf "%s\0" "--cache-from" "type=local,src=${BUILD_CACHE}"
        [ ! -d ./tags       ] || find ./tags       -type f -exec sh -c 'printf "%s\0" "--tag"       "$(cat {})"' \;
        [ ! -d ./labels     ] || find ./labels     -type f -exec sh -c 'printf "%s\0" "--label"     "$(cat {})"' \;
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build
  after_script:
    - docker logout

##
# Detect last modification dates from $APPLICATION_URLS
##
.docker_support:.trigger_on_update:.detect_app_dates: &detect_app_dates |
  detect_app_dates() {
    set -euo pipefail
    urls="${1}"
    ref="${2}"
    echo "${urls}" | tr ' ' '\n' | while read url; do
      case "${url}" in
        git*|*.git)
          log "Detecting application date from latest commit" \
              "in branch '${DOWNSTREAM_REF}' of git repository ${url}"
          repo="$(mktemp -d)"
          git clone -q --depth 1 --branch "${ref}" "${url}" "${repo}"
          app_date="$(git -C "${repo}" --no-pager log -1 --format="%ai" | xargs -0 date +%s -d)"
          ;;
        http*)
          log "Detecting application date from last modification of ${url}"
          last_modified_date="$(wget -q --spider -S "${url}" 2>&1 | sed -nE 's/\s*Last-Modified: ([^\s].+)/\1/p')"
          [ -z "${last_modified_date}" ] || app_date="$(date +%s -d "${last_modified_date}")"
          ;;
        *)
          log "Unsupported protocol for application URL '${url}'" ;;
      esac
      if [ -n "${app_date-}" ]; then
        log "Result: $(date --utc -Iseconds -d "@${app_date}")"
        echo "${app_date}"
      else
        log "No date found for application URL '${url}'"
      fi
      unset app_date
    done
  }

##
# Detect application date.
##
.docker_support:.trigger_on_update:.detect_latest_app_date: &detect_latest_app_date |
  detect_latest_app_date() {
    app_date="$(detect_app_dates "${APPLICATION_URLS}" "${DOWNSTREAM_REF}" | sort -r | head -n 1)"
    if [ -z "${app_date-}" ]; then
      log "No application date found."
    else
      log "Application:  $(date --utc -Iseconds -d "@${app_date}")"
      echo "${app_date}"
    fi
  }

##
# Detect date of latest Docker image.
##
.docker_support:.trigger_on_update:.detect_latest_image_date: &detect_latest_image_date |
  detect_latest_image_date() {
    set -euo pipefail
    case "${IMAGE_REPOSITORY}" in
      http*) repo_url="${IMAGE_REPOSITORY}" ;;
      *)     repo_url="https://hub.docker.com/v2/repositories/${IMAGE_REPOSITORY}" ;;
    esac
    log "Detecting image date from Docker repository ${repo_url}"
    image_date="$(wget -q -O - "${repo_url}/tags" | jq -r ".results[] | select(.name==\"${IMAGE_VERSION}\") | .last_updated" | xargs date +%s -d)"
    if [ -n "${image_date-}" ]; then
      log "Latest image: $(date --utc -Iseconds -d "@${image_date}")"
      echo "${image_date}"
    else
      log "No date found for Docker image '${repo_url}'"
    fi
  }

##
# Check if an update is available. If so, trigger a build.
#
# - To activate this job, set variable PIPELINE_MODE to 'update-check'.
# - The variable APPLICATION_URLS is used to check the application date;
#   it may contain a space-separated list of URLs pointing to a HTTP
#   resource or a git repository.
# - The variable IMAGE_REPOSITORY is used to check the Docker image date;
#   it may either contain an URL to an image in a Docker registry or the
#   name of an image on Docker Hub (e.g. 'owner/example-image').
# - If the image is outdated, a pipeline for $DOWNSTREAM_PROJECT on branch
#   $DOWNSTREAM_REF is triggered. Project and branch default to the current
#   environment, so that by default the current project is build.
#
# This job is designed for projects that download and build an application
# hosted externally. To automatically build a project when the external
# application is updated, create a GitLab schedule with an interval of your
# choice and set the variable PIPELINE_MODE to 'update-check'.
##
.docker_support:.trigger_on_update:
  rules:
  - if: '$PIPELINE_MODE == "update-check"'
  image: alpine
  before_script:
  - set -euo pipefail
  - apk add --no-cache coreutils jq git curl
  - log() { echo >&2 "${@}"; }
  - *detect_app_dates
  - *detect_latest_app_date
  - *detect_latest_image_date
  script:
  - |
    echo "Image repository: ${IMAGE_REPOSITORY}"
    app_date="$(detect_latest_app_date)"
    image_date="$(detect_latest_image_date)"
    if [ -z "${app_date-}" ] || [ -z "${image_date-}" ]; then
      log "An error occured while detecting dates."
      exit 1
    elif [ "${app_date}" -le "${image_date}" ]; then
      log "Image is up-to-date."
    else
      log "Image is outdated. Triggering build of project '${DOWNSTREAM_PROJECT}' with ref '${DOWNSTREAM_REF}'."
      downstream_project_url="${CI_API_V4_URL}/projects/$(jq -nr --arg v "${DOWNSTREAM_PROJECT}" '$v|@uri')"
      curl -sSL \
           --form "token=${CI_JOB_TOKEN}" \
           --form "ref=${DOWNSTREAM_REF}" \
           "${downstream_project_url}/trigger/pipeline"
    fi
