variables:
  BUILD_CONTEXT: "."
  IMAGE_NAME: "${CI_PROJECT_PATH}"
  IMAGE_VERSION: "latest"
  IMAGE_PLATFORMS: "linux/amd64"
  DOCKER_VERSION: "19.03.8"
  DOCKER_BUILDX_VERSION: "v0.3.1"
  DOCKER_CREDENTIAL_PASS_VERSION: "v0.6.3"
  DOCKER_CLI_EXPERIMENTAL: "enabled"
  BUILD_CACHE: "build-cache"
  UPDATE_CHECK: "false"

default:
  artifacts:
    expire_in: 1 hour

.docker_support:.build_image:.configure_multiarch_builder: &configure_multiarch_builder |
  docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
  mkdir -p ~/.docker/cli-plugins
  wget -q -O ~/.docker/cli-plugins/docker-buildx "https://github.com/docker/buildx/releases/download/${DOCKER_BUILDX_VERSION}/buildx-${DOCKER_BUILDX_VERSION}.linux-amd64"
  chmod +x ~/.docker/cli-plugins/docker-buildx
  docker buildx create --use --name builder

.docker_support:.build_image:.configure_docker_auth_pass: &configure_docker_auth_pass |
  wget -q -O - "https://github.com/docker/docker-credential-helpers/releases/download/${DOCKER_CREDENTIAL_PASS_VERSION}/docker-credential-pass-${DOCKER_CREDENTIAL_PASS_VERSION}-amd64.tar.gz" | tar -C /usr/bin -xz
  chmod +x /usr/bin/docker-credential-pass
  apk add gnupg
  apk add --no-cache -X https://alpine.global.ssl.fastly.net/alpine/edge/community pass
  export gpg_passphrase="${GPG_PASSPHRASE:-$(cat /dev/urandom | tr -dc 'a-zA-Z0-9!#%&*+,-./:;<=>?@^_~;' | fold -w 64 | head -n 1)}"
  cat <<EOF | gpg --batch --gen-key
  Key-Type: 1
  Name-Real: docker-credential-pass
  Passphrase: ${gpg_passphrase}
  EOF
  gpg --list-keys docker-credential-pass | grep -o '^\s\(.*\)' | tr -d ' ' | xargs pass init
  echo 'pass is initialized' | pass insert -e docker-credential-helpers/docker-pass-initialized-check
  <<EOF gpg --passphrase-fd 0 --pinentry-mode loopback -d ~/.password-store/docker-credential-helpers/docker-pass-initialized-check.gpg
  ${gpg_passphrase}
  EOF
  unset gpg_passphrase
  mkdir -p ~/.docker
  echo "{\"credsStore\":\"pass\"}" >~/.docker/config.json

.docker_support:.build_job:
  rules:
  - if: '$UPDATE_CHECK != "true"'

.docker_support:.update_job:
  rules:
  - if: '$UPDATE_CHECK == "true"'

.docker_support:.collect_tags:
  extends: .docker_support:.build_job
  image: "alpine"
  before_script:
  - set -euo pipefail
  script:
  - mkdir -p tags
  - echo >"tags/${IMAGE_VERSION}" "${IMAGE_NAME}:${IMAGE_VERSION}"
  artifacts:
    paths:
    - tags

.docker_support:.collect_labels:
  extends: .docker_support:.build_job
  image: "alpine"
  before_script:
  - set -euo pipefail
  script:
  - apk add wget jq coreutils
  - gitlab_project_metadata="$(wget -q -O - "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}?license=yes")"
  - gitlab_users_metadata="$(  wget -q -O - "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/users")"
  - value_of() { printf "%s" "${gitlab_project_metadata}" | jq -r "${1} // empty"; }
  - authors="$(printf "%s" "${gitlab_users_metadata}" | jq -r '. | map((.name // empty) + if .web_url != null then " ("+.web_url+")" else "" end) | join(", ")')"
  - oci='org.opencontainers.image'
  - mkdir -p labels
  - echo >"labels/${oci}.vendor"   "${oci}.vendor=${IMAGE_VENDOR:-${CI_PROJECT_NAMESPACE}}"
  - echo >"labels/${oci}.title"    "${oci}.title=${IMAGE_TITLE:-${IMAGE_NAME##*/}}"
  - echo >"labels/${oci}.version"  "${oci}.version=${IMAGE_VERSION}"
  - echo >"labels/${oci}.created"  "${oci}.created=${IMAGE_CREATED:-$(date -u --rfc-3339 seconds)}"
  - echo >"labels/${oci}.authors"  "${oci}.authors=${IMAGE_AUTHORS:-${authors}}"
  - echo >"labels/${oci}.url"      "${oci}.url=${IMAGE_URL:-${CI_PROJECT_URL}}"
  - echo >"labels/${oci}.revision" "${oci}.revision=${IMAGE_REVISION:-${CI_COMMIT_SHA}}"
  - echo >"labels/${oci}.ref.name" "${oci}.ref.name=${IMAGE_REF_NAME:-${CI_COMMIT_REF_NAME}}"
  - IMAGE_DOCUMENTATION="${IMAGE_DOCUMENTATION:-$(value_of .readme_url)}"
  - if [ -n "${IMAGE_DOCUMENTATION}" ]; then echo >"labels/${oci}.documentation" "${oci}.documentation=${IMAGE_DOCUMENTATION}"; fi
  - IMAGE_LICENSES="${IMAGE_LICENSES:-$(value_of .license.key)}"
  - if [ -n "${IMAGE_LICENSES}" ]; then echo >"labels/${oci}.licenses" "${oci}.licenses=${IMAGE_LICENSES}"; fi
  - IMAGE_DESCRIPTION="${IMAGE_DESCRIPTION:-$(value_of .description)}"
  - if [ -n "${IMAGE_DESCRIPTION}" ]; then echo >"labels/${oci}.description" "${oci}.description=${IMAGE_DESCRIPTION}"; fi
  artifacts:
    paths:
    - labels

.docker_support:.collect_build_args:
  extends: .docker_support:.build_job
  image: "alpine"
  rules:
  - if: '$UPDATE_CHECK != "true" && $BUILD_ARGS'
  before_script:
  - set -euo pipefail
  script:
  - mkdir -p build-args
  - echo "${BUILD_ARGS-}" | tr ' ' '\n' | while read build_arg; do [ -z "${build_arg}" ] || echo >"build-args/${build_arg%%=*}" "${build_arg}"; done
  artifacts:
    paths:
    - build-args

.docker_support:.base:
  image: "docker:${DOCKER_VERSION}"
  extends: .docker_support:.build_job
  services:
  - name: "docker:${DOCKER_VERSION}-dind"

.docker_support:.build_bare_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
  script:
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS}"
        printf "%s\0" "--cache-to" "type=local,dest=${BUILD_CACHE},mode=max"
        printf "%s\0" "--tag" "${IMAGE_NAME}:${BUILD_CACHE}"
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build
  artifacts:
    paths:
    - "${BUILD_CACHE}"

.docker_support:.with_bare_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS%%,*}"
        printf "%s\0" "--load"
        [ ! -d "${BUILD_CACHE}" ] || printf "%s\0" "--cache-from" "type=local,src=${BUILD_CACHE}"
        printf "%s\0" "--tag" "${IMAGE_NAME}:${BUILD_CACHE}"
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build

.docker_support:.publish_image:
  extends: .docker_support:.base
  before_script:
    - set -euo pipefail
    - *configure_multiarch_builder
    - *configure_docker_auth_pass
    - |
      <<EOF docker login -u "${CI_REGISTRY_USER}" --password-stdin "${CI_REGISTRY}"
      ${CI_REGISTRY_PASSWORD}
      EOF
  script:
    - |
      {
        printf "%s\0" "--platform" "${IMAGE_PLATFORMS}"
        printf "%s\0" "--push"
        [ ! -d "${BUILD_CACHE}" ] || printf "%s\0" "--cache-from" "type=local,src=${BUILD_CACHE}"
        [ ! -d ./tags       ] || find ./tags       -type f -exec sh -c 'printf "%s\0" "--tag"       "$(cat {})"' \;
        [ ! -d ./labels     ] || find ./labels     -type f -exec sh -c 'printf "%s\0" "--label"     "$(cat {})"' \;
        [ ! -d ./build-args ] || find ./build-args -type f -exec sh -c 'printf "%s\0" "--build-arg" "$(cat {})"' \;
        printf "%s\0" "${BUILD_CONTEXT}"
      } | xargs -0 docker buildx build
  after_script:
    - docker logout

.docker_support:.trigger_on_update:
  extends: .docker_support:.update_job
  image: alpine
  variables:
    DOWNSTREAM_PROJECT: "${CI_PROJECT_PATH}"
    DOWNSTREAM_REF:     "${CI_COMMIT_REF_NAME}"
    DOCKER_REPOSITORY:  "${CI_PROJECT_PATH}"
    APPLICATION_URL:    "${CI_REPOSITORY_URL}"
  before_script:
  - set -euo pipefail
  - apk add --no-cache coreutils jq git curl
  - log() { echo >&2 "${@}"; }
  - |
    detect_app_date() {
      set -euo pipefail
      case "${APPLICATION_URL}" in
        git*|*.git)
          log "Detecting application date from latest commit in branch '${DOWNSTREAM_REF}' of git repository ${APPLICATION_URL}"
          repo="$(mktemp -d)"
          git clone -q --depth 1 --branch "${DOWNSTREAM_REF}" "${APPLICATION_URL}" "${repo}"
          app_date="$(git -C "${repo}" --no-pager log -1 --format="%ai" | xargs -0 date +%s -d)" ;;
        http*)
          log "Detecting application date from last modification of ${APPLICATION_URL}"
          app_date="$(wget -q --spider -S "${APPLICATION_URL}" 2>&1 \
                      | sed -nE 's/\s*Last-Modified: ([^\s].+)/"\1"/p' \
                      | xargs date +%s -d)" ;;
        *)
          log "Unsupported protocol for application URL '${APPLICATION_URL}'" ;;
      esac
      if [ -z "${app_date}" ]; then
        log "No date found for application URL '${APPLICATION_URL}'"
        return 1
      fi
      log "Application:  $(date --utc -Iseconds -d "@${app_date}")"
      echo "${app_date}"
    }
  - |
    detect_image_date() {
      set -euo pipefail
      case "${DOCKER_REPOSITORY}" in
        http*) repo_url="${DOCKER_REPOSITORY}" ;;
        *)     repo_url="https://hub.docker.com/v2/repositories/${DOCKER_REPOSITORY}" ;;
      esac
      log "Detecting image date from Docker repository ${repo_url}"
      image_date="$(wget -q -O - "${repo_url}/tags" | jq -r '.results | max_by(.last_updated) | .last_updated' | xargs date +%s -d)"
      if [ -z "${image_date}" ]; then
        log "No date found for Docker image '${repo_url}'"
        return 1
      fi
      log "Latest image: $(date --utc -Iseconds -d "@${image_date}")"
      echo "${image_date}"
    }
  script:
  - |
    echo "Docker repository: ${DOCKER_REPOSITORY}"
    app_date="$(detect_app_date)"
    image_date="$(detect_image_date)"
    if [ -z "${app_date}" ] || [ -z "${image_date}" ]; then
      log "An error occured while detecting dates."
      exit 1
    elif [ "${app_date}" -le "${image_date}" ]; then
      log "Image is up-to-date."
    else
      log "Image is outdated. Triggering build of project '${DOWNSTREAM_PROJECT}' with ref '${DOWNSTREAM_REF}'."
      downstream_project_url="${CI_API_V4_URL}/projects/$(jq -nr --arg v "${DOWNSTREAM_PROJECT}" '$v|@uri')"
      curl -sSL \
           --form "token=${CI_JOB_TOKEN}" \
           --form "ref=${DOWNSTREAM_REF}" \
           "${downstream_project_url}/trigger/pipeline"
    fi
